# CommonCpp_Idioms
Notes on popular C++ techniques and idioms for learning purposes.

- [SFINAE - Substitution Failure Is Not An Error](#SFINAE)
- [PIMPL - Private Implementation](#PIMPL)
- [CRTP - Curiously Recurring Template Pattern](#CRTP)
- [Return Type Resolver](#ReturnTypeResolver)
- [Tag Dispatching](#TagDispatching)
- [RAII - Resources Acquisition Is Initialize](#RAII)


### SFINAE

**Definition**

SFINAE stand for Substitution Failure Is Not An Error, it is C++ feature where an invalid substitution of template parameters is not in itself an error. It is a technique to remove not matching function overrides from the overload set.

When compiler try to evaluate a template, it perform a name lookup. The template argument values are deduced from the types of the actual arguments passed into the function. 

- All occurrences of the template parameter(either return type or parameters type or both) are substituted with those deduced types.
- When this process is leads to invalid type, the particular function is removed from the overload resolution set.
- At the end, we have list of viable functions that can be used for specific call. If this set is empty, then compilation fails. In the list of the candidates functions, whose parameters match the arguments most closely is the one that is called.

**Usage**

Whenever we want to select a proper function or specialization for specific type, it also used to achieve partially template function.

Some of the example:

- Disallow narrowing or wrong conversions from wrapper types (prevent std::variant from deducing wrong types)
- Specialize a function for all kind of type traits that we have.
- std::enable_if

**std::enable_if** 

A set of tools, internally use SFINAE, allow to include or exclude overloads from possible function template or class template.

Example: if passed types are arithmetic(int, long, float..) it will work and generate T, otherwise it will fail to instantiate.

```cpp
//c++11
template <class T>
typename std::enable_if<std::is_arithmetic<T>::value, T>::type
foo(T t) {
	std::cout << "foo<arithmetic T>\n";
	return t
}

//c++17
template <class T>
typename std::enable_if_t<std::is_arithmetic_v<T>, T>
foo(T t) {
	std::cout << "foo<arithmetic>\n";
	return t;
}
```

**Alternatives to SFINAE** 

SFINAE disadvantages:

- Template errors: hard to read the error template error generated by the compiler
- Readability
- Nested template usually don't work with std::enable_if

So we have some alternative to SFINAE:
- concept //C++20
- constexpr if // C++17
- tag dispatching

**concept**

A concept is a set of constraints on template parameters evaluated at compile time

```cpp
//define a concept and use as the typename
template <class T>
concept Arithmetic = std::is_arithmetic_v<T>

template <Arithmetic T>
foo(T t) {
	return t;
}
```

**constexpr if**
the feature allows you to discard branches of an if statement at compile-time based on MPL - Private Implementaa constant expression condition.

```cpp
template <typename T>
auto get_value(T t) {
	if constepxr(std::is_pointer_v<T>)
		return *t;
	else
		return t;
}
```


### PIMPL

**Definition**

C++ technique that hide implementation, to minimize coupling, separate the declaration and actual implementation. PIMPL stand for "Pointer To Implementation" or "Private Implementation".

example taken from EffectiveCppp book:

```cpp
//widget.h

struct Pimpl; //forward declaration
class Widget
{
public:
	Widget();
	~Widget();
	Widget(const Widget& widget); //copyable
	Widget& operator=(const Widget& widget);
	Widget(Widget&& widget); //moveable
	Widget& operator=(Widget&& widget);

private:
	std::unique_ptr<Pimpl> pImpl;
};

//widget.cpp
struct Pimpl {
	std::string mString;
	std::vector<int> mVector;

	void DoSomeThing() {};
};

Widget::Widget()
	:pImpl(std::make_unique<Pimpl>())
{}

Widget::~Widget() = default; // needed to make Pimpl type complete
Widget::Widget(Widget&& widget) = default;
Widget& Widget::operator=(Widget&& widget) = default;

/* compiler not generate the default copy constructor for move - only types like std::unique_ptr, 
so have to implement*/
Widget::Widget(const Widget& widget) 
	:pImpl(std::make_unique<Pimpl>(*widget.pImpl))
{
}
Widget& Widget::operator=(const Widget& widget)
{
	*pImpl = *widget.pImpl;
	return *this;
}
```

**Usage**:

Pimpl technique hide the implement of the class and access it via pointer, so no need to recompile entire class if header file remain the same, it will reduce the build time and also reduce the dependency from client code.

Useful when apply to large class which is provide API to client.

**Disadvantage**:

Because it manages the implementation via pointer, so there is the need for heap memory allocation. 
Debugging - you donâ€™t see the details immediately, class is split

**Static PIMPL/Fast PIMPL**

Instead of construct private class on heap, use the placement new operator and create the object in an embedded buffer.
https://www.cleeus.de/w/blog/2017/03/10/static_pimpl_idiom.html 