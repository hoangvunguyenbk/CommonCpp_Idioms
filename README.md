# CommonCpp_Idioms
Notes on popular C++ techniques and idioms for learning purposes.

- [SFINAE - Substitution Failure Is Not An Error](#SFINAE)
- [PIMPL - Private Implementation](#PIMPL)
- [CRTP - Curiously Recurring Template Pattern](#CRTP)
- [Return Type Resolver](#ReturnTypeResolver)
- [Tag Dispatching](#TagDispatching)
- [RAII - Resources Acquisition Is Initialize](#RAII)


### SFINAE

**Definition**

SFINAE stand for Substitution Failure Is Not An Error, it is C++ feature where an invalid substitution of template parameters is not in itself an error. It is a technique to remove not matching function overrides from the overload set.

When compiler try to evaluate a template, it perform a name lookup. The template argument values are deduced from the types of the actual arguments passed into the function. 

- All occurrences of the template parameter(either return type or parameters type or both) are substituted with those deduced types.
- When this process is leads to invalid type, the particular function is removed from the overload resolution set.
- At the end, we have list of viable functions that can be used for specific call. If this set is empty, then compilation fails. In the list of the candidates functions, whose parameters match the arguments most closely is the one that is called.

**Usage**

Whenever we want to select a proper function or specialization for specific type, it also used to achieve partially template function.

Some of the example:

- Disallow narrowing or wrong conversions from wrapper types (prevent std::variant from deducing wrong types)
- Specialize a function for all kind of type traits that we have.
- std::enable_if

**std::enable_if** 

A set of tools, internally use SFINAE, allow to include or exclude overloads from possible function template or class template.

Example: if passed types are arithmetic(int, long, float..) it will work and generate T, otherwise it will fail to instantiate.

```cpp
//c++11
template <class T>
typename std::enable_if<std::is_arithmetic<T>::value, T>::type
foo(T t) {
	std::cout << "foo<arithmetic T>\n";
	return t
}

//c++17
template <class T>
typename std::enable_if_t<std::is_arithmetic_v<T>, T>
foo(T t) {
	std::cout << "foo<arithmetic>\n";
	return t;
}
```

**Alternatives to SFINAE** 

SFINAE disadvantages:

- Template errors: hard to read the error template error generated by the compiler
- Readability
- Nested template usually don't work with std::enable_if

So we have some alternative to SFINAE:
- concept //C++20
- constexpr if // C++17
- tag dispatching

**concept**

A concept is a set of constraints on template parameters evaluated at compile time

```cpp
//define a concept and use as the typename
template <class T>
concept Arithmetic = std::is_arithmetic_v<T>

template <Arithmetic T>
foo(T t) {
	return t;
}
```

**constexpr if**
the feature allows you to discard branches of an if statement at compile-time based on a constant expression condition.

```cpp
template <typename T>
auto get_value(T t) {
	if constepxr(std::is_pointer_v<T>)
		return *t;
	else
		return t;
}
```


### PIMPL

**Definition**

C++ technique that hide implementation, to minimize coupling, separate the declaration and actual implementation. PIMPL stand for "Pointer To Implementation" or "Private Implementation".

```cpp
//class.h

class PrivImp;
class MyClass {

public:
	//...
	void Foo();
private:
	PrivImp* mPriv;
};

//class.cpp
class PrivImp {
public:
	void DoSomething() {};
};

MyClass::MyClass()
:mPriv(new PrivImp()) {}

MyClass::~MyClass() {
	delete mPriv;
}

void MyClass::Foo() {
	mPriv->DoSomething
};
```